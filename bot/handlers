# bot/handlers.py
import io, logging, datetime, time
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, PreCheckoutQueryHandler, filters
)

from .config import BOT_TOKEN, MODEL_VISION, BOT_OWNER_ID
from .prompts import WELCOME_TEXT, HELP_TEXT
from .analyze import analyze_chart
from .formatting import format_reply
from .db import (
    ensure_user, get_user, update_user, increment_analysis,
    count_users, count_active_subs, last_payments, set_subscription_days,
    all_user_ids, add_payment_record
)

log = logging.getLogger(__name__)

# ==== Callback keys (Ø«Ø§Ø¨Øªâ€ŒÙ‡Ø§)
CB_MAIN = "main"
CB_ANALYZE = "analyze"
CB_SUBS = "subs"
CB_SUBS_PAY = "subs_pay"
CB_PROFILE = "profile"
CB_SETTINGS = "settings"
CB_SETTINGS_CONF_UP = "settings_conf_up"
CB_SETTINGS_CONF_DOWN = "settings_conf_down"
CB_SETTINGS_RISK = "settings_risk"
CB_SETTINGS_LANG = "settings_lang"

# Admin panel
CB_ADMIN = "admin"
CB_ADMIN_STATS = "admin_stats"
CB_ADMIN_GRANT = "admin_grant"
CB_ADMIN_BCAST = "admin_bcast"

# ==== ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†Ù…Ø§ÛŒØ´ÛŒ/Ù‚ÛŒÙ…Øª
ADMIN_USERNAME = "AdminOfChannel"   # â† ÛŒÙˆØ²Ø±Ù†ÛŒÙ… Ø§Ø¯Ù…ÛŒÙ† Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ú¯Ø°Ø§Ø± (Ø¨Ø¯ÙˆÙ† @)
STARS_PRICE = 399                   # 1 Ù…Ø§Ù‡Ù‡ = 399 Ø³ØªØ§Ø±Ù‡

# ==== Ú©Ù…Ú©â€ŒØªØ§Ø¨Ø¹â€ŒÙ‡Ø§
def _fmt_ts(ts):
    if not ts: return "-"
    dt = datetime.datetime.fromtimestamp(ts)
    return dt.strftime("%Y-%m-%d %H:%M")

def _is_owner(update: Update) -> bool:
    uid = (update.effective_user.id if update.effective_user else 0)
    return BOT_OWNER_ID and uid == BOT_OWNER_ID

def menu_kb():
    # 2 Ã— 2
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ØªØ­Ù„ÛŒÙ„ Ú†Ø§Ø±Øª ğŸ“ˆ", callback_data=CB_ANALYZE),
         InlineKeyboardButton("Ø®Ø±ÛŒØ¯ Ú©Ø±Ø¯ÛŒØª / Ø§Ø´ØªÙ€Ø±Ø§Ú© ğŸ›’", callback_data=CB_SUBS)],
        [InlineKeyboardButton("Ù¾Ø±ÙˆÙØ§ÛŒÙ„ ğŸ‘¤", callback_data=CB_PROFILE),
         InlineKeyboardButton("ØªÙ†Ø¸ÛŒÙ…Ø§Øª âš™ï¸", callback_data=CB_SETTINGS)]
    ])

def back_kb():
    return InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data=CB_MAIN)]])

def admin_kb():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ“Š Ø¢Ù…Ø§Ø±", callback_data=CB_ADMIN_STATS)],
        [InlineKeyboardButton("ğŸ ÙØ¹Ø§Ù„Ø³Ø§Ø²ÛŒ Ø§Ø´ØªØ±Ø§Ú© Ø¯Ø³ØªÛŒ", callback_data=CB_ADMIN_GRANT)],
        [InlineKeyboardButton("ğŸ“£ Ø¨Ø±ÙˆØ¯Ú©Ø³Øª", callback_data=CB_ADMIN_BCAST)],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data=CB_MAIN)]
    ])

# ==== Ù…Ù†ÙˆÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±ÛŒ
async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "<b>Ø±Ø§Ù‡Ù†Ù…Ø§ ğŸ“–</b>\n\n"
        "â€¢ <b>ØªØ­Ù„ÛŒÙ„ Ú†Ø§Ø±Øª ğŸ“ˆ</b>: ÛŒÚ© ØªØµÙˆÛŒØ± ÙˆØ§Ø¶Ø­ Ø§Ø² Ú†Ø§Ø±Øª Ø¨ÙØ±Ø³Øª ØªØ§ ØªØ­Ù„ÛŒÙ„ Ø´ÙˆØ¯.\n"
        "â€¢ <b>Ø®Ø±ÛŒØ¯ Ú©Ø±Ø¯ÛŒØª / Ø§Ø´ØªØ±Ø§Ú© ğŸ›’</b>: Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ â­ï¸ Ø§Ø³ØªØ§Ø±Ø² ÛŒØ§ Ø±ÛŒØ§Ù„ÛŒ.\n"
        "â€¢ <b>Ù¾Ø±ÙˆÙØ§ÛŒÙ„ ğŸ‘¤</b>: Ø¢Ù…Ø§Ø±ØŒ Ø§Ø´ØªØ±Ø§Ú© Ùˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø¨ Ø´Ù…Ø§.\n"
        "â€¢ <b>ØªÙ†Ø¸ÛŒÙ…Ø§Øª âš™ï¸</b>: ØªØºÛŒÛŒØ± Ø¢Ø³ØªØ§Ù†Ù‡ Ø§Ø¹ØªÙ…Ø§Ø¯ØŒ Ø²Ø¨Ø§Ù† Ø®Ø±ÙˆØ¬ÛŒØŒ Ø­Ø§Ù„Øª Ø±ÛŒØ³Ú©.\n\n"
        "âš ï¸ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ ØµØ±ÙØ§Ù‹ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ Ù‡Ø³ØªÙ†Ø¯ Ùˆ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù‚Ø·Ø¹ÛŒ Ù†ÛŒØ³ØªÙ†Ø¯."
    )
    await update.message.reply_text(text, parse_mode="HTML")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    ensure_user(user.id, user.username or "", (user.full_name or ""))

    text = (
        "<b>Ø¨Ù‡ Ø¨Ø§Øª ØªØ­Ù„ÛŒÙ„ Ú†Ø§Ø±Øª Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒ!</b>\n\n"
        f"<b>Ù…Ø¯Ù„: GPT-5 ğŸ«§</b>\n\n"
        "<b>Ø§Ø² Ù…Ù†ÙˆÛŒ Ø²ÛŒØ± Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:</b>"
    )
    await update.message.reply_text(text, reply_markup=menu_kb(), parse_mode="HTML")

async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    text = (
        "<b>Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ</b>\n"
        "ğŸ‘‡ ÛŒÚ©ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:\n"
        "â€¢ <b>ØªØ­Ù„ÛŒÙ„ Ú†Ø§Ø±Øª</b>: Ø¹Ú©Ø³ Ú†Ø§Ø±Øª Ø¨ÙØ±Ø³Øª ØªØ§ ØªØ­Ù„ÛŒÙ„ Ø´ÙˆØ¯.\n"
        "â€¢ <b>Ø®Ø±ÛŒØ¯ Ú©Ø±Ø¯ÛŒØª / Ø§Ø´ØªÙ€Ø±Ø§Ú©</b>: Ø¨Ø§ â­ï¸ Ø§Ø³ØªØ§Ø±Ø² ÛŒØ§ Ù¾Ø±Ø¯Ø§Ø®Øª Ø±ÛŒØ§Ù„ÛŒ.\n"
        "â€¢ <b>Ù¾Ø±ÙˆÙØ§ÛŒÙ„</b>: ÙˆØ¶Ø¹ÛŒØª Ø§Ø´ØªØ±Ø§Ú©ØŒ Ø¢Ù…Ø§Ø± ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ Ùˆ ...\n"
        "â€¢ <b>ØªÙ†Ø¸ÛŒÙ…Ø§Øª</b>: Ø¢Ø³ØªØ§Ù†Ù‡ Ø§Ø¹ØªÙ…Ø§Ø¯ØŒ Ø­Ø§Ù„Øª Ø±ÛŒØ³Ú© Ùˆ Ø²Ø¨Ø§Ù† Ø®Ø±ÙˆØ¬ÛŒ."
    )
    await q.message.edit_text(text, reply_markup=menu_kb(), parse_mode="HTML")

async def analyze_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    text = (
        "<b>ØªØ­Ù„ÛŒÙ„ Ú†Ø§Ø±Øª ğŸ“ˆ</b>\n"
        "ÛŒÚ© <b>Ø¹Ú©Ø³ ÙˆØ§Ø¶Ø­</b> Ø§Ø² Ú†Ø§Ø±Øª Ø¨ÙØ±Ø³Øª (ØªØ§ÛŒÙ…â€ŒÙØ±ÛŒÙ…/Ù†Ù…Ø§Ø¯ Ø±ÙˆÛŒ ØªØµÙˆÛŒØ± Ù…Ø´Ø®Øµ Ø¨Ø§Ø´Ø¯).\n"
        "Ù†ØªÛŒØ¬Ù‡ Ø¨Ø§ <b>Ù„Ø§Ù†Ú¯/Ø´ÙˆØ±Øª/Ù†ÙˆØªØ±ÛŒØ¯</b> Ùˆ Ø­Ø¯Ø¶Ø±Ø±/ØªØ§Ø±Ú¯Øª Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯."
    )
    await q.message.edit_text(text, reply_markup=back_kb(), parse_mode="HTML")

async def subs_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    text = (
        "<b>Ø®Ø±ÛŒØ¯ Ú©Ø±Ø¯ÛŒØª / Ø§Ø´ØªÙ€Ø±Ø§Ú© ğŸ›’</b>\n"
        f"â€¢ <b>Û± Ù…Ø§Ù‡Ù‡</b> = <b>{STARS_PRICE} â­ï¸ Stars</b>"
    )
    k = InlineKeyboardMarkup([
        [InlineKeyboardButton("Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ â­ï¸ Ø§Ø³ØªØ§Ø±Ø²", callback_data=CB_SUBS_PAY)],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data=CB_MAIN)]
    ])
    await q.message.edit_text(text, reply_markup=k, parse_mode="HTML")

async def subs_pay(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Ø§Ø±Ø³Ø§Ù„ ÙØ§Ú©ØªÙˆØ± Stars (Ø¨Ø¯ÙˆÙ† provider_token)
    q = update.callback_query
    await q.answer()
    chat_id = q.from_user.id
    await context.bot.send_invoice(
        chat_id=chat_id,
        title="Ø§Ø´ØªØ±Ø§Ú© Ù…Ø§Ù‡Ø§Ù†Ù‡",
        description="Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ ØªØ­Ù„ÛŒÙ„ Ú†Ø§Ø±Øª Ø¨Ø§ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ø¯Ù‚Øª Ø¨Ù‡ Ù…Ø¯Øª Û³Û° Ø±ÙˆØ²",
        payload=f"sub_month_{chat_id}",
        provider_token="",       # Ø¨Ø±Ø§ÛŒ Stars Ù„Ø§Ø²Ù… Ù†ÛŒØ³Øª
        currency="XTR",          # ÙˆØ§Ø­Ø¯ Ø³ØªØ§Ø±Ù‡
        prices=[LabeledPrice("Ø§Ø´ØªØ±Ø§Ú© 1 Ù…Ø§Ù‡Ù‡", STARS_PRICE)],
    )

async def precheckout_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ù‚Ø¨Ù„ Ø§Ø² Ù†Ù‡Ø§ÛŒÛŒ Ø´Ø¯Ù†
    await update.pre_checkout_query.answer(ok=True)

async def successful_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.message.from_user.id
    now = int(time.time())
    update_user(uid, {
        "subscription": {
            "active": True,
            "plan": "monthly",
            "start_ts": now,
            "end_ts": now + 30*24*3600,
            "via": "stars"
        }
    })
    # Ø«Ø¨Øª ØªØ±Ø§Ú©Ù†Ø´
    try:
        add_payment_record(uid, STARS_PRICE, update.message.successful_payment.invoice_payload)
    except Exception:
        log.exception("failed to store payment record")

    await update.message.reply_text(
        "<b>Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚ âœ…</b>\nØ§Ø´ØªØ±Ø§Ú© Ø´Ù…Ø§ Ø¨Ù‡ Ù…Ø¯Øª Û³Û° Ø±ÙˆØ² ÙØ¹Ø§Ù„ Ø´Ø¯.",
        parse_mode="HTML", reply_markup=menu_kb()
    )

async def profile_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    u = get_user(q.from_user.id)
    sub = u["subscription"]
    stats = u["stats"]
    text = (
        "<b>Ù¾Ø±ÙˆÙØ§ÛŒÙ„ ğŸ‘¤</b>\n"
        f"â€¢ <b>Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ:</b> <code>{u['user_id']}</code>\n"
        f"â€¢ <b>Ù†Ø§Ù…:</b> {u.get('name') or '-'}\n"
        f"â€¢ <b>Ù†Ø§Ù…â€ŒÚ©Ø§Ø±Ø¨Ø±ÛŒ:</b> @{u.get('username') or '-'}\n"
        f"â€¢ <b>ØªØ§Ø±ÛŒØ® Ø¹Ø¶ÙˆÛŒØª:</b> { _fmt_ts(u['created_at']) }\n\n"
        f"â€¢ <b>Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„:</b> {'âœ…' if sub['active'] else 'âŒ'}\n"
        f"â€¢ <b>Ù¾Ù„Ù†:</b> {sub['plan'] or '-'}\n"
        f"â€¢ <b>Ø´Ø±ÙˆØ¹:</b> { _fmt_ts(sub['start_ts']) }\n"
        f"â€¢ <b>Ù¾Ø§ÛŒØ§Ù†:</b> { _fmt_ts(sub['end_ts']) }\n"
        f"â€¢ <b>Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª:</b> {sub['via'] or '-'}\n\n"
        f"â€¢ <b>ØªØ¹Ø¯Ø§Ø¯ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§:</b> {stats['analyses_count']}\n"
        f"â€¢ <b>Ø¢Ø®Ø±ÛŒÙ† ØªØ­Ù„ÛŒÙ„:</b> { _fmt_ts(stats['last_analysis_ts']) }\n"
        f"â€¢ <b>Ø¢Ø®Ø±ÛŒÙ† Ø§Ø¹ØªÙ…Ø§Ø¯:</b> {stats['last_confidence'] if stats['last_confidence'] is not None else '-'}Ùª\n"
    )
    await q.message.edit_text(text, reply_markup=back_kb(), parse_mode="HTML")

def _settings_kb(u):
    s = u["settings"]
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(f"Ø¢Ø³ØªØ§Ù†Ù‡ Ø§Ø¹ØªÙ…Ø§Ø¯: {s['min_confidence']}Ùª â–", callback_data=CB_SETTINGS_CONF_DOWN),
            InlineKeyboardButton("â•", callback_data=CB_SETTINGS_CONF_UP),
        ],
        [InlineKeyboardButton(f"Ø­Ø§Ù„Øª Ø±ÛŒØ³Ú©: {s['risk_mode']}", callback_data=CB_SETTINGS_RISK)],
        [InlineKeyboardButton(f"Ø²Ø¨Ø§Ù† Ø®Ø±ÙˆØ¬ÛŒ: {s['lang']}", callback_data=CB_SETTINGS_LANG)],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ", callback_data=CB_MAIN)],
    ])

async def settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    u = get_user(q.from_user.id)
    text = (
        "<b>ØªÙ†Ø¸ÛŒÙ…Ø§Øª âš™ï¸</b>\n"
        "â€¢ <b>Ø¢Ø³ØªØ§Ù†Ù‡ Ø§Ø¹ØªÙ…Ø§Ø¯</b>: Ø§Ú¯Ø± Ø§Ø¹ØªÙ…Ø§Ø¯ Ù…Ø¯Ù„ Ø§Ø² Ø§ÛŒÙ† Ú©Ù…ØªØ± Ø¨Ø§Ø´Ø¯ØŒ Ø®Ø±ÙˆØ¬ÛŒ Ø¨Ù‡â€ŒØ¹Ù†ÙˆØ§Ù† Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹ØªØ¨Ø± Ù†Ø´Ø§Ù† Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯.\n"
        "â€¢ <b>Ø­Ø§Ù„Øª Ø±ÛŒØ³Ú©</b>: conservative / balanced / aggressive.\n"
        "â€¢ <b>Ø²Ø¨Ø§Ù† Ø®Ø±ÙˆØ¬ÛŒ</b>: fa / en."
    )
    await q.message.edit_text(text, reply_markup=_settings_kb(u), parse_mode="HTML")

async def settings_actions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    uid = q.from_user.id
    u = get_user(uid)
    data = q.data

    if data == CB_SETTINGS_CONF_UP:
        val = min(95, u["settings"]["min_confidence"] + 5)
        update_user(uid, {"settings": {"min_confidence": val}})
    elif data == CB_SETTINGS_CONF_DOWN:
        val = max(0, u["settings"]["min_confidence"] - 5)
        update_user(uid, {"settings": {"min_confidence": val}})
    elif data == CB_SETTINGS_RISK:
        order = ["conservative", "balanced", "aggressive"]
        cur = u["settings"]["risk_mode"]
        nxt = order[(order.index(cur) + 1) % len(order)]
        update_user(uid, {"settings": {"risk_mode": nxt}})
    elif data == CB_SETTINGS_LANG:
        nxt = "en" if u["settings"]["lang"] == "fa" else "fa"
        update_user(uid, {"settings": {"lang": nxt}})

    await q.answer("Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯ âœ…")
    u2 = get_user(uid)
    await q.message.edit_text("<b>ØªÙ†Ø¸ÛŒÙ…Ø§Øª âš™ï¸</b>\nÚ¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯ÛŒØ¯.", reply_markup=_settings_kb(u2), parse_mode="HTML")

# ==== ØªØ­Ù„ÛŒÙ„ Ø¹Ú©Ø³ (Ø§Ø¯ÛŒØª Ù‡Ù…Ø§Ù† Ù¾ÛŒØ§Ù…)
async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    waiting = await update.message.reply_text("<b>Ø¯Ø± Ø­Ø§Ù„ ØªØ­Ù„ÛŒÙ„ ØªØµÙˆÛŒØ±...</b> ğŸ§", parse_mode="HTML")
    try:
        photo = update.message.photo[-1]
        file = await photo.get_file()
        bio = io.BytesIO()
        await file.download_to_memory(out=bio)
        image_bytes = bio.getvalue()

        result = analyze_chart(image_bytes)
        conf = int(result.get("confidence_percent") or 0)

        u = ensure_user(update.effective_user.id, update.effective_user.username or "", update.effective_user.full_name or "")
        minc = u["settings"]["min_confidence"]

        increment_analysis(update.effective_user.id, conf=conf)

        if conf < minc:
            txt = (
                "<b>Ø³ÛŒÚ¯Ù†Ø§Ù„ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª</b> (Ø§Ø¹ØªÙ…Ø§Ø¯ Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ± Ø§Ø² Ø¢Ø³ØªØ§Ù†Ù‡ Ø´Ù…Ø§).\n"
                f"<b>Ø§Ø¹ØªÙ…Ø§Ø¯ Ù…Ø¯Ù„:</b> {conf}Ùª | <b>Ø¢Ø³ØªØ§Ù†Ù‡ Ø´Ù…Ø§:</b> {minc}Ùª\n\n"
                "Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù‡Ø´ Ø¢Ø³ØªØ§Ù†Ù‡ Ø¨Ù‡ <b>ØªÙ†Ø¸ÛŒÙ…Ø§Øª</b> Ø¨Ø±ÙˆÛŒØ¯."
            )
            await waiting.edit_text(txt, parse_mode="HTML", reply_markup=back_kb())
            return

        text = format_reply(result)
        text += f"\n\n<b>Ø­Ø§Ù„Øª Ø±ÛŒØ³Ú© ÙØ¹Ù„ÛŒ:</b> {u['settings']['risk_mode']}"
        await waiting.edit_text(text, parse_mode="HTML", reply_markup=back_kb())
    except Exception:
        log.exception("Photo handling failed")
        await waiting.edit_text("âš ï¸ Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„. Ù„Ø·ÙØ§Ù‹ Ø¹Ú©Ø³ ÙˆØ§Ø¶Ø­â€ŒØªØ± Ø¨ÙØ±Ø³Øª ÛŒØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†.", parse_mode="HTML", reply_markup=back_kb())

# ==== Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ† (/admin)
async def admin_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not _is_owner(update):
        return
    await update.message.reply_text("<b>Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†</b>", parse_mode="HTML", reply_markup=admin_kb())

async def admin_menu_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not _is_owner(update):
        await update.callback_query.answer("Ø§Ø¬Ø§Ø²Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.", show_alert=True)
        return
    q = update.callback_query
    await q.answer()
    await q.message.edit_text("<b>Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†</b>", parse_mode="HTML", reply_markup=admin_kb())

async def admin_stats_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not _is_owner(update):
        await update.callback_query.answer("Ø§Ø¬Ø§Ø²Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.", show_alert=True); return
    q = update.callback_query
    await q.answer()
    pays = last_payments(5)
    lines = []
    for p in pays:
        lines.append(f"â€¢ UID {p['user_id']} â€” {p['amount_stars']}â­ï¸ â€” <code>{p['payload']}</code>")
    txt = (
        "<b>ğŸ“Š Ø¢Ù…Ø§Ø±</b>\n"
        f"â€¢ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: <b>{count_users()}</b>\n"
        f"â€¢ Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„: <b>{count_active_subs()}</b>\n\n"
        "<b>Ø¢Ø®Ø±ÛŒÙ† Ù¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§:</b>\n" + ("\n".join(lines) if lines else "â€”")
    )
    await q.message.edit_text(txt, parse_mode="HTML", reply_markup=admin_kb())

async def admin_grant_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not _is_owner(update):
        await update.callback_query.answer("Ø§Ø¬Ø§Ø²Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.", show_alert=True); return
    q = update.callback_query
    await q.answer()
    context.user_data["ADM_MODE"] = "GRANT_WAIT"
    await q.message.edit_text(
        "<b>ÙØ¹Ø§Ù„Ø³Ø§Ø²ÛŒ Ø¯Ø³ØªÛŒ</b>\n"
        "Ø¢ÛŒØ¯ÛŒ Ø¹Ø¯Ø¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ùˆ ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ² Ø±Ø§ Ø¨ÙØ±Ø³Øª (Ù…Ø«Ø§Ù„: <code>123456789 30</code>)\n"
        "ÙÙ‚Ø· Ø¢ÛŒØ¯ÛŒ Ù‡Ù… Ø¨ÙØ±Ø³ØªÛŒØŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 30 Ø±ÙˆØ² ÙØ¹Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯.",
        parse_mode="HTML",
        reply_markup=admin_kb()
    )

async def admin_bcast_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not _is_owner(update):
        await update.callback_query.answer("Ø§Ø¬Ø§Ø²Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯.", show_alert=True); return
    q = update.callback_query
    await q.answer()
    context.user_data["ADM_MODE"] = "BCAST_WAIT"
    await q.message.edit_text(
        "<b>Ø¨Ø±ÙˆØ¯Ú©Ø³Øª</b>\nÙ…ØªÙ† Ù¾ÛŒØ§Ù… Ø±Ø§ Ø¨ÙØ±Ø³Øª ØªØ§ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø§Ø±Ø³Ø§Ù„ Ø´ÙˆØ¯.",
        parse_mode="HTML", reply_markup=admin_kb()
    )

async def admin_text_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø¯Ø± Ø­Ø§Ù„Øª Ù…Ø®ØµÙˆØµ Ø§Ø³ØªØ› ÙˆÚ¯Ø±Ù†Ù‡ Ù…Ø²Ø§Ø­Ù… Ú†Øª Ù…Ø¹Ù…ÙˆÙ„ÛŒ Ù†Ø´Ùˆ
    if not _is_owner(update):
        return
    mode = context.user_data.get("ADM_MODE")
    if not mode:
        return

    if mode == "GRANT_WAIT":
        try:
            parts = update.message.text.strip().split()
            uid = int(parts[0])
            days = int(parts[1]) if len(parts) > 1 else 30
            set_subscription_days(uid, days, via="admin", plan=f"manual_{days}d")
            context.user_data["ADM_MODE"] = None
            await update.message.reply_text(
                f"<b>Ø§ÙˆÚ©ÛŒ!</b> Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø± <code>{uid}</code> Ø¨Ø±Ø§ÛŒ <b>{days}</b> Ø±ÙˆØ² ÙØ¹Ø§Ù„ Ø´Ø¯ âœ…",
                parse_mode="HTML", reply_markup=admin_kb()
            )
        except Exception:
            await update.message.reply_text(
                "ÙØ±Ù…Øª ÙˆØ±ÙˆØ¯ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª. Ù…Ø«Ø§Ù„ ØµØ­ÛŒØ­:\n<code>123456789 30</code>",
                parse_mode="HTML", reply_markup=admin_kb()
            )

    elif mode == "BCAST_WAIT":
        text = update.message.text
        ids = all_user_ids()
        ok, fail = 0, 0
        for uid in ids:
            try:
                await context.bot.send_message(chat_id=uid, text=text, parse_mode="HTML")
                ok += 1
            except Exception:
                fail += 1
        context.user_data["ADM_MODE"] = None
        await update.message.reply_text(
            f"<b>Ø¨Ø±ÙˆØ¯Ú©Ø³Øª ØªÙ…Ø§Ù… Ø´Ø¯.</b>\nÙ…ÙˆÙÙ‚: <b>{ok}</b> | Ù†Ø§Ù…ÙˆÙÙ‚: <b>{fail}</b>",
            parse_mode="HTML", reply_markup=admin_kb()
        )

# ==== Ø«Ø¨Øª Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§
def build_app():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    # Ø¯Ø³ØªÙˆØ±Ø§Øª Ø¹Ù…ÙˆÙ…ÛŒ
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_cmd))

    # Ù…Ù†ÙˆÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
    app.add_handler(CallbackQueryHandler(main_menu,     pattern=f"^{CB_MAIN}$"))
    app.add_handler(CallbackQueryHandler(analyze_menu,  pattern=f"^{CB_ANALYZE}$"))
    app.add_handler(CallbackQueryHandler(subs_menu,     pattern=f"^{CB_SUBS}$"))
    app.add_handler(CallbackQueryHandler(subs_pay,      pattern=f"^{CB_SUBS_PAY}$"))
    app.add_handler(CallbackQueryHandler(profile_menu,  pattern=f"^{CB_PROFILE}$"))
    app.add_handler(CallbackQueryHandler(settings_menu, pattern=f"^{CB_SETTINGS}$"))
    app.add_handler(CallbackQueryHandler(
        settings_actions,
        pattern=f"^{CB_SETTINGS}.*|^{CB_SETTINGS_CONF_UP}$|^{CB_SETTINGS_CONF_DOWN}$|^{CB_SETTINGS_RISK}$|^{CB_SETTINGS_LANG}$"
    ))

    # Ù¾Ø±Ø¯Ø§Ø®Øª Stars
    app.add_handler(PreCheckoutQueryHandler(precheckout_handler))
    app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment))

    # Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†
    app.add_handler(CommandHandler("admin", admin_cmd))
    app.add_handler(CallbackQueryHandler(admin_menu_cb,  pattern=f"^{CB_ADMIN}$"))
    app.add_handler(CallbackQueryHandler(admin_stats_cb, pattern=f"^{CB_ADMIN_STATS}$"))
    app.add_handler(CallbackQueryHandler(admin_grant_cb, pattern=f"^{CB_ADMIN_GRANT}$"))
    app.add_handler(CallbackQueryHandler(admin_bcast_cb, pattern=f"^{CB_ADMIN_BCAST}$"))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, admin_text_router))

    # Ø¯Ø±ÛŒØ§ÙØª Ø¹Ú©Ø³ Ø¨Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))

    return app
